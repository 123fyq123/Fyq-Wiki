## 概述

从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径

解决问题有以下算法:

+   <a href="">迪杰斯特拉算法(Dijkstra算法)</a>
+   <a href="">弗洛伊德算法(Floyd算法)</a>
+   <a href="">Bellman-Ford算法</a>
+   <a href="">SPFA算法</a>

本章讲解最短路的各类运用

---

## 例题

### 选择最佳线路

<a href="https://www.acwing.com/problem/content/description/1139/">题目链接</a>

**题目描述**

有一天，琪琪想乘坐公交车去拜访她的一位朋友。

由于琪琪非常容易晕车，所以她想尽快到达朋友家。

现在给定你一张城市交通路线图，上面包含城市的公交站台以及公交线路的具体分布。

已知城市中共包含 n 个车站（编号1~n）以及 m 条公交线路。

每条公交线路都是 单向的，从一个车站出发直接到达另一个车站，两个车站之间可能存在多条公交线路。

琪琪的朋友住在 s 号车站附近。

琪琪可以在任何车站选择换乘其它公共汽车。

请找出琪琪到达她的朋友家（附近的公交车站）需要花费的最少时间。

**输入格式**

输入包含多组测试数据。

每组测试数据第一行包含三个整数 n,m,s，分别表示车站数量，公交线路数量以及朋友家附近车站的编号。

接下来 m 行，每行包含三个整数 p,q,t，表示存在一条线路从车站 p 到达车站 q，用时为 t。

接下来一行，包含一个整数 w，表示琪琪家附近共有 w 个车站，她可以在这 w 个车站中选择一个车站作为始发站。

再一行，包含 w 个整数，表示琪琪家附近的 w 个车站的编号。

**输出格式**

每个测试数据输出一个整数作为结果，表示所需花费的最少时间。

如果无法达到朋友家的车站，则输出 -1。

每个结果占一行。

**数据范围**

$n≤1000,m≤20000,$

$1≤s≤n,$

$0<w<n,$

$0<t≤1000$

**输入样例**

```
5 8 5
1 2 2
1 5 3
1 3 4
2 4 7
2 5 6
2 3 5
3 5 1
4 5 1
2
2 3
4 3 4
1 2 3
1 3 4
2 3 2
1
1
```

**输出样例**

```
1
-1
```

### 题解

对于多起点到任意终点，我们可以建立一个虚拟的超级源点，这个点与所有起点的距离为0，最后只需要计算出这个超级源点到终点的距离即可

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m,s;
const int N=1005,M=4e4+5;
int head[N],e[M],w[M],ne[M],idx=0;
void add(int a,int b,int c)
{
    e[idx]=b;
    w[idx]=c;
    ne[idx]=head[a];
    head[a]=idx++;
}

int dis[N];
bool vis[N];
typedef pair<int,int> PII;
priority_queue<PII,vector<PII>,greater<PII> >heap;
void djs(int s,int t)
{
    while(heap.size()) heap.pop();
    memset(vis,false,sizeof(vis));
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;
    heap.push({0,s});
    while(heap.size())
    {
        auto cur = heap.top();
        heap.pop();
        int pos=cur.second;
        if(vis[pos]) continue;
        vis[pos]=true;
        for(int i=head[pos];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dis[j]>dis[pos]+w[i])
            {
                dis[j]=dis[pos]+w[i];
                heap.push({dis[j],j});
            }
        }
    }
    if(dis[t]==0x3f3f3f3f) cout<<"-1"<<endl;
    else cout<<dis[t]<<endl;
}
int main()
{
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(0);
    while(cin>>n>>m>>s)
    {
        idx=0;
        memset(head,-1,sizeof(head));
        for(int i=1;i<=m;i++)
        {
            int a,b,c;
           cin>>a>>b>>c;
            add(a,b,c);
        }
        int w;
        cin>>w;
        for(int i=1;i<=w;i++) // 超级源点
        {
            int a;
            cin>>a;
            add(0,a,0);
        }
        djs(0,s);
    }
    return 0;
}
```